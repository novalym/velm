# =================================================================================
# == GNOSTIC ARCHETYPE: WORKER SWARM (V-Î©-TOTALITY)                             ==
# =================================================================================
# @description: Materializes a high-scale distributed task queue system. Orchestrates Python (Celery) and Node.js (BullMQ) workers over a shared Redis backbone. Features metabolic auto-scaling, dead-letter forensics, and real-time swarm telemetry.
# @category: Integrations
# @tags: celery, bullmq, redis, distributed-systems, workers, async, backend, scale
# @difficulty: Grand Architect
# @is_integration: true
# @dna: redis_host=redis-vault, swarm_concurrency=8, use_flower=true, use_cron=true
# =================================================================================

# --- I. THE ALTAR OF GNOSTIC WILL ---
$$ redis_host = "redis-vault"
$$ redis_port = 6379
$$ swarm_concurrency = 8
$$ dashboard_port = 5555

# Contextual Triage
$$ is_python = {{ (project_type in ['python', 'poetry', 'fastapi']) | default(true) }}
$$ is_node = {{ (project_type in ['node', 'nextjs', 'express']) | default(false) }}
$$ package_name = {{ package_name | default(project_slug | snake) }}

# --- II. THE SWARM INFRASTRUCTURE (Matter) ---
infra/swarm/
    docker-compose.swarm.yml :: """
    version: '3.8'

    services:
      # [THE NERVOUS SYSTEM]: High-Speed Redis Backbone
      redis-vault:
        image: redis:7-alpine
        container_name: {{ project_slug }}_redis_vault
        command: redis-server --save 60 1 --loglevel warning --maxmemory 256mb --maxmemory-policy allkeys-lru
        ports:
          - "{{ redis_port }}:6379"
        networks:
          - gnostic_mesh
        healthcheck:
          test: ["CMD", "redis-cli", "ping"]
          interval: 5s
          timeout: 3s
          retries: 5

      # [THE KINETIC LIMB]: Distributed Worker Node
      worker:
        build: 
          context: ../../
          dockerfile: infra/swarm/Dockerfile.worker
        container_name: {{ project_slug }}_worker
        environment:
          - REDIS_URL=redis://{{ redis_host }}:{{ redis_port }}/0
          - ENVIRONMENT=production
          - LOG_LEVEL=INFO
        env_file: ../../.env
        depends_on:
          redis-vault:
            condition: service_healthy
        networks:
          - gnostic_mesh
        deploy:
          replicas: 2 # Initial swarm density
          resources:
            limits:
              memory: 512M

      # [THE OCULAR MONITOR]: Swarm Dashboard (Flower)
      {% if is_python %}
      flower:
        image: mher/flower:latest
        container_name: {{ project_slug }}_flower
        environment:
          - CELERY_BROKER_URL=redis://{{ redis_host }}:{{ redis_port }}/0
        ports:
          - "{{ dashboard_port }}:5555"
        depends_on:
          - redis-vault
        networks:
          - gnostic_mesh
      {% endif %}

    networks:
      gnostic_mesh:
        external: true
        name: {{ project_slug }}_gnostic_mesh
    """

    Dockerfile.worker :: """
    FROM python:3.12-slim-bookworm
    WORKDIR /app
    
    # [ASCENSION 1]: System Hardening
    RUN apt-get update && apt-get install -y --no-install-recommends curl && rm -rf /var/lib/apt/lists/*
    
    RUN pip install poetry
    COPY pyproject.toml poetry.lock* ./
    RUN poetry config virtualenvs.create false && poetry install --no-root --only main
    
    COPY src /app/src
    
    # [THE VOW]: Unbuffered execution for stream logs
    ENV PYTHONUNBUFFERED=1
    
    # Command to ignite the swarm as a Celery worker
    CMD ["celery", "-A", "src.{{ package_name }}.worker.celery_app", "worker", "--loglevel=info", "--concurrency={{ swarm_concurrency }}"]
    """

# --- III. THE LOGIC STRATUM: PYTHON / CELERY (The Mind) ---
@if {{ is_python }}
src/{{ package_name }}/
    worker/
        __init__.py :: ""
        
        # [ASCENSION 2]: The Swarm Conductor (Celery App)
        celery_app.py :: """
        import os
        from celery import Celery
        from celery.schedules import crontab

        # Forge the Celery organ
        app = Celery(
            '{{ project_slug }}',
            broker=os.getenv('REDIS_URL', 'redis://{{ redis_host }}:{{ redis_port }}/0'),
            backend=os.getenv('REDIS_URL', 'redis://{{ redis_host }}:{{ redis_port }}/0'),
            include=['src.{{ package_name }}.worker.tasks']
        )

        # [ASCENSION 3]: SWARM CONFIGURATION (The Laws of Motion)
        app.conf.update(
            task_serializer='json',
            accept_content=['json'],
            result_serializer='json',
            timezone='UTC',
            enable_utc=True,
            task_track_started=True,
            task_time_limit=3600, # 1 Hour hard limit
            worker_prefetch_multiplier=1, # Fair distribution
            # [ASCENSION 4]: THE ACHRONAL SCHEDULER (Cron)
            beat_schedule={
                'swarm-heartbeat-every-minute': {
                    'task': '{{ project_slug }}.heartbeat',
                    'schedule': 60.0,
                },
            }
        )

        if __name__ == '__main__':
            app.start()
        """

        # [ASCENSION 5]: The Gnostic Tasks (The Will)
        tasks.py :: """
        import time
        import logging
        from .celery_app import app
        
        Logger = logging.getLogger("SwarmTask")

        @app.task(name="{{ project_slug }}.conduct_heavy_rite", bind=True, max_retries=3)
        def conduct_heavy_rite(self, payload: dict):
            \"\"\"
            Performs a high-order Gnostic rite in the background.
            \"\"\"
            try:
                Logger.info(f"ðŸŒ€ Swarm conducting rite: {payload.get('rite_id')}")
                
                # Simulate metabolic load
                time.sleep(5) 
                
                return {"status": "SUCCESS", "revelation": "Matter transfigured."}
            except Exception as e:
                Logger.error(f"âŒ Rite fractured: {e}")
                # Exponential backoff retry
                raise self.retry(exc=e, countdown=2 ** self.request.retries)

        @app.task(name="{{ project_slug }}.heartbeat")
        def swarm_heartbeat():
            Logger.info("ðŸ’“ SWARM_HEARTBEAT: Resonant.")
        """

    core/
        # [ASCENSION 6]: The Swarm Dispatcher (The Hand)
        dispatcher.py :: """
        from ..worker.celery_app import app as celery_app

        class SwarmDispatcher:
            \"\"\"
            The interface to delegate will to the Swarm.
            \"\"\"
            @staticmethod
            def dispatch(rite_name: str, payload: dict):
                \"\"\"Schedules a task in the background swarm.\"\"\"
                return celery_app.send_task(
                    "{{ project_slug }}.conduct_heavy_rite",
                    args=[{"rite_id": rite_name, **payload}]
                )

            @staticmethod
            def get_status(task_id: str):
                \"\"\"Scries the result of a background rite.\"\"\"
                return celery_app.AsyncResult(task_id).state
        """

    # Dependencies
    pyproject.toml += """
    celery = {extras = ["redis"], version = "^5.4.0"}
    redis = "^5.0.1"
    """
@endif

# --- IV. THE LOGIC STRATUM: NODE / BULLMQ (The Eye) ---
@if {{ is_node }}
src/worker/
    # [ASCENSION 7]: The BullMQ Swarm (Node.js)
    swarm_acolyte.ts :: """
    import { Worker, Job } from 'bullmq';
    import IORedis from 'ioredis';

    const connection = new IORedis(process.env.REDIS_URL || 'redis://{{ redis_host }}:{{ redis_port }}');

    /**
     * [THE SWARM ACOLYTE]: High-performance Node.js worker
     */
    const worker = new Worker('{{ project_slug }}_queue', async (job: Job) => {
      console.log(`[SWARM] Perceiving Task ${job.id}:`, job.name);
      
      // Heavy Ocular Logic
      await new Promise(r => setTimeout(r, 2000));
      
      return { status: 'RESOLVED', result: 'Ocular data processed.' };
    }, { 
      connection,
      concurrency: {{ swarm_concurrency }} 
    });

    worker.on('completed', (job) => console.log(`âœ… Task ${job.id} concluded.`));
    worker.on('failed', (job, err) => console.error(`âŒ Task ${job?.id} fractured:`, err));
    """

    package.json:
        dependencies += {
            "bullmq": "^5.8.0",
            "ioredis": "^5.4.1"
        }
@endif

# --- V. THE CONTROL PLANE (Makefile) ---
Makefile:
    .PHONY: swarm-up swarm-down swarm-logs swarm-scale

    $SWARM_COMPOSE = infra/swarm/docker-compose.swarm.yml

    swarm-up: ## Ignite the Worker Swarm
        @echo "ðŸ”­ Awakening the Multitude..."
        @docker network create {{ project_slug }}_gnostic_mesh 2>/dev/null || true
        @docker-compose -f $($SWARM_COMPOSE) up -d
        @echo "âœ… Swarm manifest. Dashboard at http://localhost:{{ dashboard_port }}"

    swarm-down: ## Dissolve the Swarm
        @echo "ðŸŒ‘ Returning the Multitude to the void..."
        @docker-compose -f $($SWARM_COMPOSE) down

    swarm-scale: ## Increase swarm density (Usage: make swarm-scale n=5)
        @docker-compose -f $($SWARM_COMPOSE) up -d --scale worker=$(n)

    swarm-logs: ## Gaze upon the swarm's collective consciousness
        @docker-compose -f $($SWARM_COMPOSE) logs -f worker

# --- VI. THE MAESTRO'S WILL (Rites of Ignition) ---
%% post-run
    proclaim: "The [bold cyan]Worker Swarm[/bold cyan] is materializing."
    
    # 1. Sanctum Preparation
    >> mkdir -p infra/swarm
    >> mkdir -p src/{{ package_name }}/worker

    # 2. Network Verification
    proclaim: "Verifying Gnostic Mesh network..."
    >> docker network create {{ project_slug }}_gnostic_mesh || true
    
    # 3. Final Proclamation
    proclaim: "[bold green]âœ… Swarm ready for Deployment.[/bold green]"
    proclaim: "To ignite the multitude:"
    proclaim: "  1. [bold cyan]make swarm-up[/bold cyan]"
    proclaim: "  2. Scry the swarm at [bold magenta]http://localhost:{{ dashboard_port }}[/bold magenta]"
    proclaim: "  3. To scale the workforce: [bold cyan]make swarm-scale n=4[/bold cyan]"

%% on-heresy
    proclaim: "[bold red]Swarm inception fractured.[/bold red] Purging shards..."
    rm -rf infra/swarm/ src/{{ package_name }}/worker/